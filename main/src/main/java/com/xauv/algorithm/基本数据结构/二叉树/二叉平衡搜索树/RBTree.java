package com.xauv.algorithm.基本数据结构.二叉树.二叉平衡搜索树;
/*
       /\   /\             /\.__                      
___  __)/___)/  __ _____  _)/|  |   _______  __ ____  
\  \/  /\__  \ |  |  \  \/ / |  |  /  _ \  \/ // __ \ 
 >    <  / __ \|  |  /\   /  |  |_(  <_> )   /\  ___/ 
/__/\_ \(____  /____/  \_/   |____/\____/ \_/  \___  >
      \/     \/                                    \/
*/


/**
 * @Date 2022/1/2 16:48
 * @Author Administrator
 * @Package com.xauv.algorithm.基本数据结构
 * @Desc
 *
 * 红黑树性质
 *
 * 1.节点要么是 RED 要么是 BLACK
 * 2.根节点是 BLACK
 * 3.叶子节点都是 BLACK，叶子节点包括空节点
 * 4.RED 的子节点都是 BLACK，RED 的父节点是 BLACK
 * 5.从任一节点到叶子节点的所有路径所经过的 BLACK 节点数是相同的
 *
 * 维护好这 5 条性质，就能够保证这棵树是平衡的
 *
 *
 * 比如树：[?] 代表黑色节点，其他是红色节点
 *          ┌──────[55]─────┐
 *          │               │
 *      ┌──38─┐           ┌─80─┐
 *      │     │           │    │
 *  ┌─[25]─┐ [46]─┐   ┌─[76]  [88]
 *  │      │      │   │
 * 17      33     50 72
 *
 * 插入节点时，都是在叶子节点处插入，并且，它时红色的，因为当它为红色时，更容易去维护上面的 5 条性质
 *  插入节点为红色更容易满足 5 条性质的原因：
 *  - 条件 1 肯定满足
 *  - 条件 2 肯定满足（除了插入根节点）
 *  - 条件 3 天然满足，因为叶子节点包括空节点，空节点都是黑色的
 *  - 条件 4 不一定满足，插入红色节点时，总是会破会这条性质，其他性质不会被破坏
 *  - 条件 5 插入新节点是个红色时，这个红色节点还会有 2 个隐藏的黑色 null 节点，其实对于 从任一节点到叶子节点经过黑色节点并没有任何增加，因此 条件 5 天然满足
 * 如果插入值的话，是插入在叶子节点下面，能插入的位置是：
 * 17左 17右 33左 33右 46左 50左 50右 72左 72右 76右 88左 88右
 *
 * 其中插入时有 12 种情况（如上），有 4 种情况可以直接插入而不需要做任何调整
 * 但是，有 8 种情况会违背性质 4
 *
 * 红黑树与 4 阶B树等价，等价转换为：
 *                                33 [55] 80
 *     17 [25] 33         [46] 50            72 [76]          88
 *
 * 转化后的 B 树共 5 个节点
 * 其中每个节点都是以黑色的为 红黑子树 树的根节点
 * 注意：等价转化为 B 树后，所有节点的组合只有 4 种情况，就像上面看到的 B 树的第二层：
 * 节点种类包括：红黑红   黑红   红黑  黑
 *
 *
 * ===========================================================================================================
 * =====================================插入场景：共 12 种情况====================================================
 * ===========================================================================================================
 *
 *
 * ******************************************************************************
 *
 * 无需调整情况，共 4 种
 *  其中，新节点（新节点都是红色）插入到黑色叶子节点下面。都是不用做任何调整的，直接插入即可，插入后也满足所有性质
 *  也就是：插入到 46左 76右 88左 88右，都是不需要任何调整，插入完成之后还是一棵红黑树
 *  同时，插入到这些节点后，他们组成的 B 树节点还是属于 {红黑红   黑红   红黑  黑} 这四种情况
 *
 * 但是插入在红色节点的左或者右，就出现了双红，就不满足红黑树的性质 4 了，因此我们需要做出一些调整
 *
 * ******************************************************************************
 *
 * LL RR 情况，共 2 种
 *  插入到 红黑左 和 黑红右 ，也就是插入到 50 右，72 左 时，
 *  如果直接插入，则 B 树节点会出现 黑红红，红红黑的情况，不满足 红黑树等价为 B 树的性质，也不满足红黑树性质 4
 *  如果直接插入到 50右或者 72 左时（插入 52 和 60），如图
 *
 *          ┌─────────[55]────────┐
 *          │                     │
 *      ┌──38─┐                 ┌─80─┐
 *      │     │                 │    │
 *  ┌─[25]─┐ [46]─┐         ┌─[76]  [88]
 *  │      │      │         │
 * 17      33     50─┐   ┌─72
 *                   │   │
 *                   52 60
 *
 *  其中 52 和 60 的父节点都是红色，不满足红黑树性质 4，则需要调整
 *  [46] - 50 - 52 这条线就是 RR 情况
 *  [76] - 72 - 60 是 LL 情况
 *  对于这两种情况（LL RR），需要对节点进行旋转，具体做法：
 *  对于 RR 情况，需要左旋转 [46]，并将 [46] 变为红色， 50 变为这个子树的根节点，并且染成黑色
 *  对于 LL 情况，需要右旋转 [76]，并将 [76] 变为红色，72 变为子树根节点，并染成黑色
 *
 * ******************************************************************************
 *
 *  RL LR 情况，共 2 种
 *  插入到 红黑右 或 黑红左，也就是插入到 50左，72 右时
 *  比如插入 48 和 74，如图：
 *          ┌──────[55]─────┐
 *          │               │
 *      ┌──38─┐           ┌─80─┐
 *      │     │           │    │
 *  ┌─[25]─┐ [46]─┐   ┌─[76]  [88]
 *  │      │      │   │
 * 17      33   ┌─50 72─┐
 *              │       │
 *             48       74
 *
 *  可以看到 [46] - 50 - 48 和  [76] - 72 - 74 这两条线，明显就是 RL LR 情况
 *  需要注意的是， [46] 只有一个孩子，[76] 也是只有一个孩子，他们才叫做 RL LR 情况
 *  对于 RL 情况，需要先对 50 右旋转，再对 [46] 左旋转，这样 48 就成了这棵子树的根节点，就把 48 染成黑色， [46] 染成红色即可
 *  对于 LR 情况，需要先对 72 左旋转，再对 [76] 右旋转，74 成为子树根节点，并且将 74 染成黑色，[76] 染成红色
 *
 * ******************************************************************************
 *
 *  其他情况，上溢情况，共 4 种
 *  插入到 红黑红 的左右，比如 插入 10 20 30 36
 *
 *              ┌──────[55]─────┐
 *              │               │
 *          ┌──38─┐           ┌─80─┐
 *          │     │           │    │
 *     ┌──[25]─┐ [46]─┐   ┌─[76]  [88]
 *     │       │      │   │
 *  ┌─17─┐   ┌─33─┐   50 72
 *  │    │   │    │
 * 10    20 30    36
 *
 * 看到
 * [25] - 17 - 10
 * [25] - 17 - 20
 * [25] - 33 - 30
 * [25] - 33 - 36
 * 都违背了条件 4
 *
 * 可以发现插入的节点 10 20 30 36 的叔父节点都是红色，
 * 上面的那些插入情况，其叔父节点要么没有，要么就不是红色
 * 因此，可以通过叔父节点是不是 红色 来区分是不是属于这 4 种情况
 *
 * 比如：插入 10
 * 只需要将 10 的父节点和叔父节点染成黑色，并且将祖父节点向上合并，祖父节点当作新添加节点处理即可，对 10 这个插入操作调整结果为：
 *             ┌──────[55]─────┐
 *             │               │
 *          ┌─38─┐           ┌─80─┐
 *          │    │           │    │
 *      ┌──25─┐ [46]─┐   ┌─[76]  [88]
 *      │     │      │   │
 *  ┌─[17]─┐ [33]    50 72
 *  │      │
 * 10      20
 *
 * 这样 原本是红色的 [17] [33] 独立出来并且变成了黑色
 * 10 的祖父节点 25 作为新插入的节点处理，过程如下：
 * 由于新插入节点都是红色，因此 25 先变成红色，现在就相当于 25 插入到了 红色节点的左边，相当于 插入到 红黑红的左边，并且是 LL 情况，
 * 对于 25 这种情况，这种情况其实和 10 的情况是一样的，祖父节点是红色，因此对 25 进行相同处理：
 * 首先将 25 的父节点和叔父节点染称黑色，变为：
 *              ┌───────[55]──────┐
 *              │                 │
 *          ┌─[38]─┐           ┌─[80]─┐
 *          │      │           │      │
 *      ┌──25─┐   [46]─┐   ┌─[76]    [88]
 *      │     │        │   │
 *  ┌─[17]─┐ [33]      50 72
 *  │      │
 * 10      20
 *
 * 再将 [55] 当作新加入节点处理，然后再走一遍红黑树调整的流程即可：如下：
 * 先将 [55] 染成红色， 发现 55 为根节点，直接染成黑色，无需继续调整，最终结果和上图一致：
 *
 * 这样插入 10 这个新节点的调整就结束了
 *
 * ******************************************************************************
 *
 *
 *
 * ===========================================================================================================
 * =====================================删除场景=======================================================
 * ===========================================================================================================
 *
 *
 * 删除场景：
 * 1.删除 RED 节点
 * 2.删除 BLACK 节点
 *
 * ******************************************************************************
 *
 * 对于场景 1：删除红色节点
 * 1.1 删除红色节点不需要任何调整
 * 为什么不需要调整呢？
 * 思考：假如红色节点是叶子节点，那么删除了它不会影响性质 5
 * 假如红色节点是非叶子节点，
 *  - 如果是度为 1 的节点，删除了它，其实对性质 5 没有任何影响，
 *    删除了这个红色节点，从上往下经过的黑色节点仍然是相等的，只不过是少经历了一次红色节点
 *  - 如果是度为 2 的节点，删除了它，其实对性质 5 也没有任何影响，
 *    删除了这个红色节点，从上往下经过的黑色节点仍然是相等的，只不过是少经历了一次红色节点
 * 因此，无论如何，只要被删除的是红色节点，不管它是度为几，都是直接删除，不用再经过任何处理
 *
 * ******************************************************************************
 *
 * 对于场景 2：删除 黑色节点
 *
 * 上文提到，红黑树等价成 4 阶 B 树之后，B 树只存在 4 种节点：
 * 红黑红  黑红  红黑  黑
 *
 * 2.1 对于 红黑红，删除黑色节点：
 * 可以看到 黑色节点的度为 2，在二叉搜索树中，删除度为 2 的节点都是先找到前驱或者后继进行删除，然后再进行值替换
 * 因此，删除 红黑红 这种情况，都是物理删除叶子节点
 * notice: 红黑红 这种情况，前驱后继都是红色节点
 *
 * 2.2 对于 黑红，红黑 ，删除黑色节点
 * 可以看到这两种情况，黑色节点的度都是 1，删除度为 1 的节点，我们是直接物理删除节点，并且用其子节点顶替它的位置
 *
 * 2.3 对于 黑，删除黑色节点
 * 可以看到，黑色节点是孤零零的叶子节点，删除情况比较复杂 ······
 *
 * ******************************************************************************
 *
 *
 * 1.删除红色节点不需要任何调整
 * 2.删除 红黑红 中的黑节点，直接使用 黑节点的前驱（左红）后继（右红）替代删除，然后替换节点值
 * 3.删除 红黑  黑红 中的黑节点，同样也是删除黑色节点的前驱或者后继，然后进行值替换，最后再将替换节点染黑即可
 * 4.删除 黑 节点，
 *
 *
 * 红黑树：
 *          ┌──────[55]─────┐
 *          │               │
 *      ┌──38─┐           ┌─80─┐
 *      │     │           │    │
 *  ┌─[25]─┐ [46]─┐   ┌─[76]  [88]
 *  │      │      │   │
 * 17      33     50 72
 *
 * 场景 1：删除红色节点
 * 比如删除 17 33 50 72，都是直接断开节点的链即可，删除后变为：
 *          ┌──────[55]─────┐
 *          │               │
 *      ┌──38─┐           ┌─80─┐
 *      │     │           │    │
 *    [25]   [46]       [76]  [88]
 *
 * 再删除 38，也就是删除 [25] 或者 [36]，这样就变成了场景 5 的情况了，后面介绍
 *
 * 场景 2：删除 红黑红 中的黑，
 * 在图中只有一个节点符合 红黑红，也就是删除 [25]
 * 只需要找到前驱或者后继，比如找到前驱 17，删除 17，并将 17 的值替换到 [25] 上即可，删除完变为
 *
 *          ┌──────[55]─────┐
 *          │               │
 *      ┌──38─┐           ┌─80─┐
 *      │     │           │    │
 *    [17]─┐ [46]─┐   ┌─[76]  [88]
 *         │      │   │
 *         33     50 72
 *
 * 需要注意的是：红黑树的节点删除复用二叉搜索树的删除逻辑，
 * 二叉搜索树的删除逻辑是：将 [25] 删除， 17 顶上（顶替 25 的位子），这样二叉搜索树的删除逻辑就完成了，二叉搜索树删除完之后树变为：
 *          ┌──────[55]─────┐
 *          │               │
 *      ┌──38─┐           ┌─80─┐
 *      │     │           │    │
 *     17─┐  [46]─┐   ┌─[76]  [88]
 *        │       │   │
 *        33      50 72
 * 但 17 还是红色，出现了 38 - 17 双红的情况，这种情况只需要将 17 染黑
 * -- 17 顶上之后，还是红色，需要将 17 染黑，变为：
 *          ┌──────[55]─────┐
 *          │               │
 *      ┌──38─┐           ┌─80─┐
 *      │     │           │    │
 *    [17]─┐ [46]─┐   ┌─[76]  [88]
 *         │      │   │
 *         33     50 72
 *
 * 场景 3：删除 黑红 中的黑
 * 在图中，只有 [46] 符合 黑红特征
 * 只需要找到后继 50 （因为没有前驱），将 50 删除，并且将 50 的值替换到 [46] 即可，删除完之后变为
 *
 *          ┌──────[55]─────┐
 *          │               │
 *      ┌──38─┐           ┌─80─┐
 *      │     │           │    │
 *  ┌─[25]─┐ [50]     ┌─[76]  [88]
 *  │      │          │
 * 17      33        72
 *
 *
 *
 *
 * 场景 4：删除 红黑 中的黑
 * 在图中，只有 [76] 符合 红黑特征
 * 只需找到 [76] 前驱 72，将 72 删除，并且将 72 的值替换到 [76]即可，删除完成之后变为
 *
 *          ┌──────[55]─────┐
 *          │               │
 *      ┌──38─┐           ┌─80─┐
 *      │     │           │    │
 *  ┌─[25]─┐ [46]─┐     [72]  [88]
 *  │      │      │
 * 17      33     50
 *
 *
 *
 * 场景 5：删除 黑，这种场景比较复杂，我们换一棵树
 *
 * 红黑树：
 *
 *          ┌──────[55]─────┐
 *          │               │
 *      ┌──38─┐           ┌─80─┐
 *      │     │           │    │
 *  ┌─[25]─┐ [46]     ┌─[76]  [88]
 *  │      │          │
 * 17      33         72
 *
 *
 * ******************************************************************************
 * 情况 1：
 * 删除的黑色节点的兄弟节点有红色子节点 (被删除的这个黑色节点的兄弟能借子节点)
 * 比如 删除 [46] [88]
 * [46] 的兄弟节点是 [25]， [25] 有两个红色子节点，[46] 被删除时，可以向 [25] 借一个
 * 比如借 33，首先将 33 擦除掉，树变为
 *
 *          ┌──────[55]─────┐
 *          │               │
 *      ┌──38             ┌─80─┐
 *      │                 │    │
 *  ┌─[25]            ┌─[76]  [88]
 *  │                 │
 * 17                 72
 *
 * 发现很像 LL 的情况，这时候需要让 38 右旋转，
 * 且旋转后的子树根节点需要继承原来子树根节点的颜色（33继承38的红色），
 * 且左右必须要染成黑色，因为相对于 4 阶 B 树，左右要成为独立的 B 树叶子节点，因此，需要将左右（[25]和38）染成黑色
 * 变为
 *
 *          ┌──────[55]─────┐
 *          │               │
 *      ┌── 33 ─┐         ┌─80─┐
 *      │       │         │    │
 *   ┌─[25]    [38]    ┌─[76]  [88]
 *   │                 │
 *   17                72
 *
 *
 *
 * 比如 删除 [88]，删除后变为：
 *
 *          ┌──────[55]─────┐
 *          │               │
 *      ┌──38─┐           ┌─80
 *      │     │           │
 *  ┌─[25]─┐ [46]     ┌─[76]
 *  │      │          │
 * 17      33         72
 *
 * [88] 的兄弟节点是 [76]，[76] 有一个红色子节点， [88]只能借这个红色子节点，
 * 这很像 LL 的情况，
 * 那么需要对 80 进行右旋转，
 * 且旋转后的子树根节点需要继承原来子树根节点的颜色（76继承80的红色），
 * 且左右必须要染成黑色，因为相对于 4 阶 B 树，左右要成为独立的 B 树叶子节点，因此，需要将左右（72 和 80）染成黑色
 * 变为
 *          ┌──────[55]─────┐
 *          │               │
 *      ┌──38─┐           ┌─76─┐
 *      │     │           │    │
 *  ┌─[25]─┐ [46]       [72]  [80]
 *  │      │
 * 17      33
 *
 *
 * ******************************************************************************
 * 刚才说到的是 LL 情况，其实一共有 LL LR (LR RL) 三种情况
 *
 * 1.1 LR 情况
 *          ┌──────[55]─────┐
 *          │               │
 *        [46]           ┌─-80-─┐
 *                       │      │
 *                      [76]─┐  [88]
 *                           │
 *                           78
 * 删除 [80]，变为 LR 情况，
 * LR 情况就是 L R 双旋
 * 先对 [76]左旋，再对 80 右旋，然后 78 变成子树根节点，78 继承原来根节点 80 的红色，新的子节点 76 78 强制染成黑色
 * 调整后变为
 *          ┌──────[55]─────┐
 *          │               │
 *        [46]           ┌─-78─┐
 *                       │     │
 *                      [76]  [80]
 *
 * ******************************************************************************
 * 1.2 LL 情况
 *          ┌──────[55]─────┐
 *          │               │
 *        [46]           ┌─-80-─┐
 *                       │      │
 *                    ┌─[76]   [88]
 *                    │
 *                    72
 * 删除 [80]，变为 LL 情况，
 * LL 情况就是 R 单旋
 * 直接对 80 右旋，然后 [76]变为子树根节点，并继承原根节点80的红色，并且新的子节点强制染成黑色（再强调一下，因为新的子节点要独立成新的B树根节点，根节点都是黑色，因此需要强制染成黑色）
 * 调整后变为
 *          ┌──────[55]─────┐
 *          │               │
 *        [46]           ┌─-76-─┐
 *                       │      │
 *                      [72]   [80]
 *
 * ******************************************************************************
 * 1.3 （LR RL）情况，
 * 其实这种情况就是被删除节点的兄弟节点有左右两个红色孩子节点
 *          ┌──────[55]─────┐
 *          │               │
 *        [46]           ┌─-80-─┐
 *                       │      │
 *                    ┌─[76]─┐  [88]
 *                    │      │
 *                    72     78
 * 发现，[88]的兄弟节点[76]有两个红色子节点
 * 如果借72，变成 LR 情况，如果借 78 变成 LL 情况，因此我们只需要随便借一个就行，
 * 我们如果借 72，变成 LR。就需要 2 次旋转，如果我们借 78，变成 LL。只需要一次旋转，
 * 我们借 78 示例（借78成为 LL 情况，只需要一次右旋转）：
 * 同样，旋转后 [76] 成为子树根节点，并继承原子树节点80的红色，并且强制将 76 的子节点 72 80 染成黑色
 * 调整后变为
 *          ┌──────[55]─────┐
 *          │               │
 *        [46]           ┌─-76-─┐
 *                       │      │
 *                      [72]  ┌─[80]
 *                            │
 *                           78
 *
 * ******************************************************************************
 *
 *
 * 情况 2
 * condition 1 被删除的黑色节点的兄弟节点没有任何红色节点（兄弟节点没有可以借的子节点）
 * condition 2 被删除的黑色节点的兄弟是黑色
 *
 * 基于情况 2，首先被删除的黑色兄弟节点没有红色子节点，又产生两种情况
 *
 * 情况 2.1 被删除节点的父节点是红色
 * 比如树：
 *          ┌──────[55]─────┐
 *          │               │
 *        [46]           ┌─-80-─┐
 *                       │      │
 *                      [76]   [88]
 *
 * 我们删除 [88]，我们发现 [88] 的兄弟节点 [76] 没有红色子节点可以借
 * 并且，[88] 的父节点是红色，那我们只需要调换 80 和 [76] 的颜色即可，其实是将 80 染黑，[76]染红，而不是调换颜色
 *
 * 变为
 *          ┌──────[55]─────┐
 *          │               │
 *        [46]           ┌─[80]
 *                       │
 *                       76
 *
 *
 * 情况 2.2 被删除节点的父节点是黑色
 * 比如树：这种情况删除 [88] 必然出现 [80] 下溢出，因为相对于 4 阶 B 树，[80] 左右肯定没有任何节点了， （80 的左右被 [76] 和 [88] 占据）
 *
 *
 *                  │
 *          ┌──────[80]─────┐
 *          │               │
 *        [76]            [88]
 *
 * 我们删除 [88] 发现兄弟节点 [76] 没有子节点可借，父节点[80]又是黑色的，
 * 我们只能把 [80]拿下来，然后再把 [80]当作新删除的节点处理即可
 * 调整后变为
 *
 *                  │
 *                  ?  ─────┐
 *                          │
 *                     ┌───[80]
 *                    76
 * 发现 [80] 的父节点是不确定的，还可能产生下溢，我们只需要将 [80]的父节点 ? 当作新的被删除的节点再进行一次处理即可
 *
 *
 * ******************************************************************************
 * 情况 3
 * condition 1 被删除的黑色节点的兄弟节点没有任何红色节点（兄弟节点没有可以借的子节点）
 * condition 2 被删除的黑色节点的兄弟是红色
 *
 * 比如树：
 *          ┌──────[80]─────┐
 *          │               │
 *        ┌─55─┐           [88]
 *        │    │
 *       [46] [76]
 *
 * 我们删除 [88]，发现其兄弟节点 55 是红色，
 * 这种情况，我们就必须借兄弟节点的儿子 [76] 成为自己的兄弟，也就是成为 [80] 的左孩子（[88]是 [80]的右孩子，因此[76]成为兄弟只能是左孩子）
 * [76] 成为 80 的左孩子的话，只需要对 80 进行右旋转
 * 首先需要将 兄弟节点染成黑色，父节点染成红色，然后对父节点进行右旋转
 *
 * 首先染色 变为：
 *           ┌────── 80 ─────┐
 *           │               │
 *        ┌─[55]─┐          [88]
 *        │      │
 *       [46]   [76]
 *
 * 其实 [88] 被删除后是：
 *           ┌────── 80
 *           │
 *        ┌─[55]─┐
 *        │      │
 *       [46]   [76]
 *
 * 这样就成为 LL 情况
 *
 * 对 80 右旋转变为
 *
 *        ┌─[55]─┐
 *        │      │
 *       [46]  ┌─80
 *             │
 *            [76]
 *
 * 我们现在还是考虑 [88] 没有被删除：
 *        ┌─[55]─┐
 *        │      │
 *       [46]  ┌─80─┐
 *             │    │
 *            [76] [88]
 *
 * 那么执行对 [88] 删除不就是情况 1 和情况 2 的情况么
 * 我们看到 [88] 的兄弟节点 [76] 是黑色的，且没有任何节点可以借
 * 因此我们看它的父节点，发现父节点 80 是黑色，因此我们直接让 80 和 [76] 颜色互换（其实不是颜色互换，就是把 80 染黑，[76]染红），变为：
 *
 *        ┌─ [55] ─┐
 *        │        │
 *       [46]   ┌─[80]
 *              │
 *             76
 */
public class RBTree<E extends Comparable<E>> extends BalanceBinarySearchTree<E> {

    private static final boolean RED = false;

    private static final boolean BLACK = true;

    /**
     * 1.染色
     * 2.
     * @param node
     */
    @Override
    protected void afterAdd(Node<E> node) {
        Node<E> parent = node.parent;
        // 如果添加的是根节点，那么将其染成黑色
        if (parent == null) {
            color(node, BLACK);
            return;
        }
        // 如果父节点是黑色，无需处理
        /*------------------无需处理情况，4 种-----------------*/
        if (isBlack(parent)) {
            return;
        }

        // 判断是否上溢情况，只需要判断 uncle
        // 叔父节点
        Node<E> uncle = parent.sibling();
        // 祖父节点
        Node<E> grand = parent.parent;

        /*------------------叔父节点为红色，上溢情况，4 种-----------------*/
        if (isRed(uncle)) {
            black(parent);
            black(uncle);
            // 祖父节点当作新添加节点处理：首先染色，然后走新插入流程
            afterAdd(red(grand));
            return;
        }
        /*------------------叔父节点不为红色，4 种，LL RR LR RL，需要旋转情况-----------------*/
        if (parent.isLeftChild()) {
            if (node.isLeftChild()) {
                // LL
                black(parent);
                red(grand);
                rotateRight(grand);
            } else {
                // LR
                black(node);
                red(grand);
                rotateLeft(parent);
                rotateRight(grand);
            }
        } else {
            if (node.isLeftChild()) {
                // RL
                black(node);
                red(grand);
                rotateRight(parent);
                rotateLeft(grand);
            } else {
                // RR
                black(parent);
                red(grand);
                rotateLeft(grand);
            }
        }
    }

    /**
     * 代码思路：
     * 如果被删除节点是红色节点：无需处理
     *
     * 如果被删除节点是黑色节点，且兄弟节点是黑色，并且有红色孩子可以借，那么进行旋转操作
     * 如果被删除节点是黑色节点，且兄弟节点是黑色，并且没有红色孩子可以借，且父节点是红色，那么直接将父节点染黑，兄弟节点染红即可
     * 如果被删除节点是黑色节点，且兄弟节点是黑色，并且没有红色孩子可以借，且父节点是黑色，那么需要将父节点染红，兄弟节点的孩子节点（一定是黑色）染红，
     *      再对父节点进行右旋转（这一步就是让兄弟的孩子节点【侄子】成为自己的兄弟），
     *      这样就又回到了上面的几种情况，那么再对被删除节点执行一次删除操作即可
     * @param node
     * @param replacement
     */
    @Override
    protected void afterRemove(Node<E> node, Node<E> replacement) {

        // 属于场景 1
        // 如果删除的是红色节点，直接删除，无需任何调整
        if (isRed(node)) {
            return;
        }
        // 属于场景 2，3，4
        // 如果用于取代 node 的节点，从而成为 node.parent 的子节点的节点 replacement 是红色
        // 只需要将 替代元素 染黑即可
        if (isRed(replacement)) {
            black(replacement);
            return;
        }

        // 删除根节点，无需处理，直接返回
        if (root == node) {
            return;
        }

        // 属于场景 5
        // 删除的是黑色的叶子节点
        Node<E> parent = node.parent;
        // 优先考虑兄弟能否借节点，首先如果能借，兄弟必须是黑色

        // 判断被删除的 node 是左还是右，不能通过 node.sibling()来获取，因为 parent.left 或者 parent.right 已经指向 null 了
        boolean left = parent.left == null;
        Node<E> sibling = left ? parent.right : parent.left;



    }

    @Override
    protected Node<E> createNode(E element, Node<E> parent) {
        return new RBNode<>(element, parent);
    }

    private Node<E> color(Node<E> node, boolean color) {
        if (node == null) {
            return null;
        }
        ((RBNode<E>) node).color = color;
        return node;
    }

    private Node<E> red(Node<E> node) {
        return this.color(node, RED);
    }

    private Node<E> black(Node<E> node) {
        return this.color(node, BLACK);
    }

    /**
     * 如果 node 为空，表示隐藏节点，隐藏节点是黑色的
     * @param node
     * @return
     */
    private boolean colorOf(Node<E> node) {
        return node == null ? BLACK : ((RBNode<E>) node).color;
    }

    private boolean isBlack(Node<E> node) {
        return colorOf(node);
    }

    private boolean isRed(Node<E> node) {
        return !colorOf(node);
    }

    @Override
    public Object string(Object node) {
        return node.toString();
    }

    private static class RBNode<E> extends Node<E> {

        /**
         * false: RED
         * true: BLACK
         */
        boolean color = RED;

        public RBNode(E element, Node<E> parent) {
            super(element, parent);
        }

        @Override
        public String toString() {
            if (color == RED) {
                return String.valueOf(element);
            } else {
                return "[" + element + "]";
            }
        }
    }
}
