package com.xauv.algorithm.基本数据结构.图;
/*
       /\   /\             /\.__                      
___  __)/___)/  __ _____  _)/|  |   _______  __ ____  
\  \/  /\__  \ |  |  \  \/ / |  |  /  _ \  \/ // __ \ 
 >    <  / __ \|  |  /\   /  |  |_(  <_> )   /\  ___/ 
/__/\_ \(____  /____/  \_/   |____/\____/ \_/  \___  >
      \/     \/                                    \/
*/

/**
 *
 * @Date 2022/10/26 12:33
 * @Author Administrator
 * @Package com.xauv.algorithm.基本数据结构.图
 * @Desc
 *
 * 两个顶点之间权值之和最小的路径
 *
 * 有向图 无向图都可用，但不能有负权环
 *
 * 比如有图：
 *
 *           A ——20——— B ——17——— C
 *           │         │
 *           26        46
 *           │         │
 *           C ———98—— D ——33——— E
 *
 *
 * A -> B 最短路径 20
 * A -> E 最短路径 20 +46 +33
 *
 * 无权图，最短路径：无权图代表每条边权值为 1，边数最少即最短
 *
 *           A ————— B ————— C
 *           │       │
 *           │       │
 *           │       │
 *           C ————— D ————— E
 *
 *
 * 有负权边，但没有负权环时，也有最短路径
 *
 * B -> C 是负权边，但不形成环，可以有最短路径
 *
 *           A ——20——— B —— -17 ——— C
 *           │         │
 *           26       46
 *           │         │
 *           C ———98—— D ———33———— E
 *
 *
 *
 * B -> D 这条边是负权边，但他形成了环，没有最短路径
 *
 *           A ——20——— B ——17——— C
 *           │         │
 *           26       -46
 *           │         │
 *           C ———98—— D ——33——— E
 *
 *
 *
 * —————————————— 最短路径算法 ————————————————
 *
 *
 * —————————————— Dijkstra ————————————————
 * 单源头最短路径算法（从一个顶点开始到其他顶点的算法）
 * 1.Dijkstra 迪杰斯特拉算法
 * 使用前提：不能有负权【边】，负权环更不能有
 *
 * 过程：
 * 从一个顶点开始，不断对其出边进行松弛操作
 *
 *
 *
 * —————————————— Bellman-Ford ————————————————
 * 2.Bellman-Ford 贝尔曼-福特算法
 * 支持负权边，可以检测出负权环
 *
 * 过程：
 * 对所有边进行 V-1 次松弛操作，得出所有可能的结果
 *
 * 假设有图：
 * A--[-3]-->B--[1]-->C--[1]-->D--[1]-->E
 * 0         ∞        ∞        ∞        ∞
 *
 * 首先对 A->B 进行松弛，我们可以立即得到 A->B 的最短路径 = -3
 * 然后对 B->C 进行松弛，现在 A->C 最短路径为 无穷，松弛后发现，B->C 最短路径为 1，然后立即可知： A->C的最短路径为 -3 + 1 = -2
 * 然后对 C->D 进行松弛，现在 A->D 最短路径为 无穷，松弛后发现，C->D 最短路径为 1，然后立即可知，A->D的最短路径为 -2 + 1 = -1
 * 最后对 D->E 进行松弛 ·········
 *
 * 根据上面我们可以发现，对所有边松弛一次，我们就知道 A 到所有节点的最短路径
 * 同理可知，我们对所有边再松弛一次，就知道 B 到其他所有节点的最短路径
 * ......
 * 同理，我们对所有边松弛 V-1 次，就能知道 从任意节点开始，到任意节点结束 的最短路径，也就知道了所有可能的结果
 *
 *
 *
 * —————————————— Floyd ————————————————
 * 多源头最短路径算法（从多个源头开始到其他节点的算法）
 * 1.Floyd 佛洛依德算法
 *
 *
 *
 *
 */
public class 最短路径 {


}
